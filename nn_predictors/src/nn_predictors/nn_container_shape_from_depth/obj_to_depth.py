import vtk
# from pycaster import pycaster
import numpy as np
from PIL import Image
import cv2
from math import cos, sin
import random
import os

import pycaster
import argparse

def pixel_to_world(params, x, y, start_point, angle, dist=1000):

    x -= params[2]
    y -= params[3]

    pos = [dist * x / params[0], -dist * y / params[1], dist]

    rotated_pos = [pos[0], 
                   cos(angle) * pos[1] + sin(angle) * pos[2], 
                   cos(angle) * pos[2] - sin(angle) * pos[1]]
    return rotated_pos

def main(args):
    if args.image_width > 0 and args.image_height > 0:
        width = args.image_width
        height = args.image_height
    else:
        width = args.image_size
        height = args.image_size

    fx = args.focal_length
    fy = args.focal_length
    cx = width / 2
    cy = height / 2
    camera_params = [fx, fy, cx, cy]

    camera_distance = args.camera_distance




    output_path = args.output_path




    with open(os.path.join(output_path, "train.txt"), 'a') as train_file:
        with open(os.path.join(output_path, "test.txt"), 'a') as test_file:
            for j in range(0, 10):
                for i in range(0, 285):

                    file_name = 'autogenerated_' + str(i) + 'iteration_' +str(j) + '.png'
                    depth_file_path = os.path.join(output_path, 'depth_images', file_name)

                    if args.resume: # Skips duplicates
                        if os.path.isfile(depth_file_path):
                            print "Already generated: ", file_name
                            continue

                    if args.read_params:
                        param_file_path = os.path.join(output_path, 'params', 'autogenerated_' + str(i)+'iteration_'+str(j)+'_params.txt')
                        if not os.path.isfile(param_file_path):
                            print "No param file found: ", i, j
                            continue

                        with open(param_file_path, 'r') as param_file:
                            for line in param_file.readlines():
                                if line.split()[0] == 'scaling_factor':
                                    scale = float(line.split()[1])
                    else:
                        scale = 1

                    caster = pycaster.rayCaster.fromSTL("/home/karl/glass/nn_container_shape_from_depth/stl_files/autogenerated_" + str(i) + ".stl", scale=1.0)

                
                    angle = - random.random() * np.pi * 2 / 8 # j / 4.0

                    unrotated_pos = np.array([random.random() * camera_distance / 20,
                                              random.random() * camera_distance / 20,
                                              -camera_distance]) / scale

                    pos_angle = angle #+ np.pi / 8 * random.random() - np.pi / 16

                    start_point = np.array([unrotated_pos[0],
                                            cos(pos_angle) * unrotated_pos[1] + sin(pos_angle) * unrotated_pos[2],
                                            cos(pos_angle) * unrotated_pos[2] - sin(pos_angle) * unrotated_pos[1]])

                    depths = np.ones((height, width)) * 1000

                    points = []

                    for x in range(0, width, 1):
                        for y in range(0, height, 1):
                            target = pixel_to_world(camera_params, x, y, start_point, angle)

                            intersections = caster.castRay(start_point, target)

                            distances = [np.linalg.norm(np.array(intersect) - start_point) for intersect in intersections]

                            if args.add_ground_plane:
                                if start_point[1] > 0 and target[1] < 0:
                                    direction = start_point - target
                                    distance = np.linalg.norm(start_point[1] / direction[1] * direction)
                                    distances.append(distance)

                            # Scales the pixels
                            distances = [d * 50 * scale for d in distances]

                            # Defaults to white if no intersect
                            distances.append(255)
                            depths[y, x] = min(distances)


                    img = Image.fromarray(depths)
                    
                    
                    cv2.imwrite(depth_file_path, depths)
                    
                    print "Saved", i, j

                    if random.random() < args.test_fraction:
                        test_file.write(file_name + '\n')
                    else:
                        train_file.write(file_name + '\n')


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('--no_resume', action='store_false', dest='resume')
    parser.add_argument('--focal_length', default=200, type=float, help="The focal length of the camera")
    

    parser.add_argument('--image_size', default=256, type=int, help="The size of the image")
    parser.add_argument('--image_width', default=-1, type=int, help="The width of the image. Will overwrite image_size")
    parser.add_argument('--image_height', default=-1, type=int, help="The height of the image. Will overwrite image_size")


    parser.add_argument('--camera_distance', default=4, type=float, 
        help="The distance the camera will be away from the center of the object")

    parser.add_argument('--add_ground_plane', default=True, type=bool, help="Should there be a simulated ground plane")

    parser.add_argument('--test_fraction', default=0.1, type=float, help="Fraction of images to set aside for testing")

    parser.add_argument('--read_params', default=False, type=bool, help="Should the program get scale from param file?")


    parser.add_argument('--output_path', default='data_with_pause', type=str)

    args = parser.parse_args()
    main(args)
